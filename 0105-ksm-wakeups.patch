diff -up linux-6.4/kernel/watchdog.c.74~ linux-6.4/kernel/watchdog.c
--- linux-6.4/kernel/watchdog.c.74~	2023-07-21 23:42:38.011478052 +0200
+++ linux-6.4/kernel/watchdog.c	2023-07-21 23:43:31.106315314 +0200
@@ -39,7 +39,7 @@ unsigned long __read_mostly watchdog_ena
 int __read_mostly watchdog_user_enabled = 1;
 static int __read_mostly watchdog_hardlockup_user_enabled = WATCHDOG_HARDLOCKUP_DEFAULT;
 static int __read_mostly watchdog_softlockup_user_enabled = 1;
-int __read_mostly watchdog_thresh = 10;
+int __read_mostly watchdog_thresh = 40;
 static int __read_mostly watchdog_hardlockup_available;
 
 struct cpumask watchdog_cpumask __read_mostly;
diff -up linux-6.4/mm/ksm.c.74~ linux-6.4/mm/ksm.c
--- linux-6.4/mm/ksm.c.74~	2023-06-26 01:29:58.000000000 +0200
+++ linux-6.4/mm/ksm.c	2023-07-21 23:42:38.011478052 +0200
@@ -2498,9 +2498,14 @@ static int ksm_scan_thread(void *nothing
 
 		if (ksmd_should_run()) {
 			sleep_ms = READ_ONCE(ksm_thread_sleep_millisecs);
-			wait_event_interruptible_timeout(ksm_iter_wait,
-				sleep_ms != READ_ONCE(ksm_thread_sleep_millisecs),
-				msecs_to_jiffies(sleep_ms));
+			if (sleep_ms >= 1000)
+				wait_event_interruptible_timeout(ksm_iter_wait,
+					sleep_ms != READ_ONCE(ksm_thread_sleep_millisecs),
+					msecs_to_jiffies(round_jiffies_relative(sleep_ms)));
+			else
+				wait_event_interruptible_timeout(ksm_iter_wait,
+					sleep_ms != READ_ONCE(ksm_thread_sleep_millisecs),
+					msecs_to_jiffies(sleep_ms));
 		} else {
 			wait_event_freezable(ksm_thread_wait,
 				ksmd_should_run() || kthread_should_stop());
